---
title: "SensorThings API Demo"
author: 
  - Kyle Onda^[Internet of Water, kyle.onda@duke.edu]
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    fig_width: 8
    fig_height: 8
    theme: readable
  
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)


```
## SensorThings: Interoperability for georeferenced observation data

You can do great things with SensorThings API. Any instance of SensorThings API can be interacted with using the same functions. Below, I've written a collection of helper functions and a function called `sta_mapview()` that takes as an input the URL of any SensorThings API endpoint, and turns it into an interactive leaflet map.
```{r, echo=FALSE}
convert_links <- function(x) {
  for(n in names(x)) {
    if(is.character(x[[n]])) {
      test <- grepl("^http", x[[n]])
      x[[n]][test] <- paste0('<a href="', 
                             x[[n]][test], 
                             '" target="_blank">', 
                             x[[n]][test], 
                             '</a>')
    }
  }
  x
}

getThings_Locations <- function(api){
  call <- URLencode(paste0(api,"/Things?$expand=Locations($select=location;$top=1)&$resultFormat=GeoJSON"))
  result <- sf::read_sf(call)
}

getLocationsCall <- function(call){
    json <- jsonlite::fromJSON(call,flatten=TRUE)$value
    json<-sta_locs_as_sf(json)
   
}

sta_location_parse <- function(locs){
  locs <-do.call(rbind.data.frame, lapply(locs, function(x) {
     x <- toString(unlist(x))}))
  names(locs) <- "coords"
  locs$coords[which(is.null(locs$coords) | locs$coords=="")]<-"0,0"
  locs <- data.frame(do.call('rbind', strsplit(locs$coords,',',fixed=TRUE)))
  names(locs) <- c("lon","lat")
  locs$lon <- as.numeric(locs$lon)
  locs$lat <- as.numeric(locs$lat)
  return(locs)
}

sta_locs_as_sf <- function(json){
    locs <- sta_location_parse(json$location.coordinates)
    json <- cbind(json,locs)
    json <- sf::st_as_sf(json, coords = c('lon','lat'), crs = 4326)
    json$location.coordinates <- NULL
    return(json)
}

getLocations <- function(api){
  call <- URLencode(paste0(api,"/Locations"))
  response <- jsonlite::fromJSON(URLencode(paste0(call,"?$count=true")))
  if (is.null(response$`@iot.nextLink`)){
    x <- getLocationsCall(call)
  } else {
    skip <- strsplit(response$`@iot.nextLink`,"skip=")[[1]][2]
    skip <- as.numeric(strsplit(skip,split="&")[[1]][1])
    count <- response$`@iot.count`
    k <- floor(count/skip)
    list <- paste0(call,"?$skip=",0:k*skip)
    x<-purrr::map(list,getLocationsCall)
    x <- do.call(dplyr::bind_rows,x)
  }
  return(x)
}

sta_iterate <- function(call,response){
    skip <- strsplit(response$`@iot.nextLink`,"skip=")[[1]][2]
    skip <- as.numeric(strsplit(skip,split="&")[[1]][1])
    count <- response$`@iot.count`
    k <- floor(count/skip)
    list <- paste0(call,"?$skip=",0:k*skip)
    x<-purrr::map(list,getLocationsCall)
    x <- do.call(dplyr::bind_rows,x)
}


getMostRecentResults <- function(api,skip=0){
  call <- paste0(api,"/Things?$expand=Locations($select=location;%20$top=1),Datastreams($top=1)/Observations($top=1)&$resultFormat=GeoJSON&$skip=",skip)
  result <- sf::read_sf(call)
}

sta_mapview <- function(api, ...){
  mapview::mapview(convert_links(getLocations(api)), ...)
}

```

 Below, I show how this function can be used to quickle create a map visualization of three separate SensorThings API endpoints (the one offered by NMBGMR, a proxy of the USGS National Groundwater Monitoring Network, and a proxy of the NMED instance of SDWIS/State)

```{r setup, results='asis'}
api_nmbgmr <- "https://st.newmexicowaterdata.org/FROST-Server/v1.1"
api_usgs <- "https://sta-demo.internetofwater.dev/api/v1.1"
api_nmed <- "https://e-enterprise-test.apigee.net/sdwis/sta/v1.0"

sta_mapview(api_usgs,col.regions="green", layer.name="National Groundwater Monitoring Network") + 
  sta_mapview(api_nmbgmr, col.regions="red", layer.name="New Mexico Bureau of Geology and Mineral Resources") + 
  sta_mapview(api_nmed, col.regions="orange", layer.name="NMED SDWIS", cex=3)
```




